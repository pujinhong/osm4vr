/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/three@0.147.0/examples/js/utils/BufferGeometryUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function(){function e(e){let t,r,o,n=0;for(let i=0;i<e.length;++i){const s=e[i];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=s.array.constructor),t!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=s.itemSize),r!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=s.normalized),o!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.normalized must be consistent across matching attributes."),null;n+=s.array.length}const i=new t(n);let s=0;for(let t=0;t<e.length;++t)i.set(e[t].array,s),s+=e[t].array.length;return new THREE.BufferAttribute(i,r,o)}function t(e){const t=e.data.array.constructor,r=e.count,o=e.itemSize,n=e.normalized,i=new t(r*o);let s;s=e.isInstancedInterleavedBufferAttribute?new THREE.InstancedBufferAttribute(i,o,n,e.meshPerAttribute):new THREE.BufferAttribute(i,o,n);for(let t=0;t<r;t++)s.setX(t,e.getX(t)),o>=2&&s.setY(t,e.getY(t)),o>=3&&s.setZ(t,e.getZ(t)),o>=4&&s.setW(t,e.getW(t));return s}THREE.BufferGeometryUtils={},THREE.BufferGeometryUtils.computeMikkTSpaceTangents=function(e,t,r=!0){if(!t||!t.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!e.hasAttribute("position")||!e.hasAttribute("normal")||!e.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function o(e){if(e.normalized||e.isInterleavedBufferAttribute){const t=new Float32Array(e.getCount()*e.itemSize);for(let r=0,o=0;r<e.getCount();r++)t[o++]=e.getX(r),t[o++]=e.getY(r),e.itemSize>2&&(t[o++]=e.getZ(r));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}const n=e.index?e.toNonIndexed():e,i=t.generateTangents(o(n.attributes.position),o(n.attributes.normal),o(n.attributes.uv));if(r)for(let e=3;e<i.length;e+=4)i[e]*=-1;return n.setAttribute("tangent",new THREE.BufferAttribute(i,4)),e!==n&&e.copy(n),e},THREE.BufferGeometryUtils.computeMorphedAttributes=function(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type THREE.BufferGeometry."),null;const t=new THREE.Vector3,r=new THREE.Vector3,o=new THREE.Vector3,n=new THREE.Vector3,i=new THREE.Vector3,s=new THREE.Vector3,u=new THREE.Vector3,f=new THREE.Vector3,a=new THREE.Vector3;function l(e,l,c,m,E,g,d,b){t.fromBufferAttribute(l,E),r.fromBufferAttribute(l,g),o.fromBufferAttribute(l,d);const h=e.morphTargetInfluences;if(c&&h){u.set(0,0,0),f.set(0,0,0),a.set(0,0,0);for(let e=0,l=c.length;e<l;e++){const l=h[e],b=c[e];0!==l&&(n.fromBufferAttribute(b,E),i.fromBufferAttribute(b,g),s.fromBufferAttribute(b,d),m?(u.addScaledVector(n,l),f.addScaledVector(i,l),a.addScaledVector(s,l)):(u.addScaledVector(n.sub(t),l),f.addScaledVector(i.sub(r),l),a.addScaledVector(s.sub(o),l)))}t.add(u),r.add(f),o.add(a)}e.isSkinnedMesh&&(e.boneTransform(E,t),e.boneTransform(g,r),e.boneTransform(d,o)),b[3*E+0]=t.x,b[3*E+1]=t.y,b[3*E+2]=t.z,b[3*g+0]=r.x,b[3*g+1]=r.y,b[3*g+2]=r.z,b[3*d+0]=o.x,b[3*d+1]=o.y,b[3*d+2]=o.z}const c=e.geometry,m=e.material;let E,g,d;const b=c.index,h=c.attributes.position,T=c.morphAttributes.position,y=c.morphTargetsRelative,B=c.attributes.normal,p=c.morphAttributes.position,A=c.groups,R=c.drawRange;let w,H,G,x,z,U,I;const S=new Float32Array(h.count*h.itemSize),v=new Float32Array(B.count*B.itemSize);if(null!==b)if(Array.isArray(m))for(w=0,G=A.length;w<G;w++)for(z=A[w],U=Math.max(z.start,R.start),I=Math.min(z.start+z.count,R.start+R.count),H=U,x=I;H<x;H+=3)E=b.getX(H),g=b.getX(H+1),d=b.getX(H+2),l(e,h,T,y,E,g,d,S),l(e,B,p,y,E,g,d,v);else for(U=Math.max(0,R.start),I=Math.min(b.count,R.start+R.count),w=U,G=I;w<G;w+=3)E=b.getX(w),g=b.getX(w+1),d=b.getX(w+2),l(e,h,T,y,E,g,d,S),l(e,B,p,y,E,g,d,v);else if(Array.isArray(m))for(w=0,G=A.length;w<G;w++)for(z=A[w],U=Math.max(z.start,R.start),I=Math.min(z.start+z.count,R.start+R.count),H=U,x=I;H<x;H+=3)E=H,g=H+1,d=H+2,l(e,h,T,y,E,g,d,S),l(e,B,p,y,E,g,d,v);else for(U=Math.max(0,R.start),I=Math.min(h.count,R.start+R.count),w=U,G=I;w<G;w+=3)E=w,g=w+1,d=w+2,l(e,h,T,y,E,g,d,S),l(e,B,p,y,E,g,d,v);return{positionAttribute:h,normalAttribute:B,morphedPositionAttribute:new THREE.Float32BufferAttribute(S,3),morphedNormalAttribute:new THREE.Float32BufferAttribute(v,3)}},THREE.BufferGeometryUtils.computeTangents=function(){throw new Error("BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.")},THREE.BufferGeometryUtils.deepCloneAttribute=function(e){return e.isInstancedInterleavedBufferAttribute||e.isInterleavedBufferAttribute?t(e):e.isInstancedBufferAttribute?(new THREE.InstancedBufferAttribute).copy(e):(new THREE.BufferAttribute).copy(e)},THREE.BufferGeometryUtils.deinterleaveAttribute=t,THREE.BufferGeometryUtils.deinterleaveGeometry=function(e){const r=e.attributes,o=e.morphTargets,n=new Map;for(const e in r){const o=r[e];o.isInterleavedBufferAttribute&&(n.has(o)||n.set(o,t(o)),r[e]=n.get(o))}for(const e in o){const r=o[e];r.isInterleavedBufferAttribute&&(n.has(r)||n.set(r,t(r)),o[e]=n.get(r))}},THREE.BufferGeometryUtils.estimateBytesUsed=function(e){let t=0;for(const r in e.attributes){const o=e.getAttribute(r);t+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t},THREE.BufferGeometryUtils.interleaveAttributes=function(e){let t,r=0,o=0;for(let n=0,i=e.length;n<i;++n){const i=e[n];if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=i.array.length,o+=i.itemSize}const n=new THREE.InterleavedBuffer(new t(r),o);let i=0;const s=[],u=["getX","getY","getZ","getW"],f=["setX","setY","setZ","setW"];for(let t=0,r=e.length;t<r;t++){const r=e[t],o=r.itemSize,a=r.count,l=new THREE.InterleavedBufferAttribute(n,o,i,r.normalized);s.push(l),i+=o;for(let e=0;e<a;e++)for(let t=0;t<o;t++)l[f[t]](e,r[u[t]](e))}return s},THREE.BufferGeometryUtils.mergeBufferAttributes=e,THREE.BufferGeometryUtils.mergeBufferGeometries=function(t,r=!1){const o=null!==t[0].index,n=new Set(Object.keys(t[0].attributes)),i=new Set(Object.keys(t[0].morphAttributes)),s={},u={},f=t[0].morphTargetsRelative,a=new THREE.BufferGeometry;let l=0;for(let e=0;e<t.length;++e){const c=t[e];let m=0;if(o!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in c.attributes){if(!n.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[t]&&(s[t]=[]),s[t].push(c.attributes[t]),m++}if(m!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(f!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in c.morphAttributes){if(!i.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===u[t]&&(u[t]=[]),u[t].push(c.morphAttributes[t])}if(r){let t;if(o)t=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;t=c.attributes.position.count}a.addGroup(l,t,e),l+=t}}if(o){let e=0;const r=[];for(let o=0;o<t.length;++o){const n=t[o].index;for(let t=0;t<n.count;++t)r.push(n.getX(t)+e);e+=t[o].attributes.position.count}a.setIndex(r)}for(const t in s){const r=e(s[t]);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" attribute."),null;a.setAttribute(t,r)}for(const t in u){const r=u[t][0].length;if(0===r)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[t]=[];for(let o=0;o<r;++o){const r=[];for(let e=0;e<u[t].length;++e)r.push(u[t][e][o]);const n=e(r);if(!n)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" morphAttribute."),null;a.morphAttributes[t].push(n)}}return a},THREE.BufferGeometryUtils.mergeGroups=function(e){if(0===e.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let t=e.groups;if(t=t.sort(((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start)),null===e.getIndex()){const t=e.getAttribute("position"),r=[];for(let e=0;e<t.count;e+=3)r.push(e,e+1,e+2);e.setIndex(r)}const r=e.getIndex(),o=[];for(let e=0;e<t.length;e++){const n=t[e],i=n.start,s=i+n.count;for(let e=i;e<s;e++)o.push(r.getX(e))}e.dispose(),e.setIndex(o);let n=0;for(let e=0;e<t.length;e++){const r=t[e];r.start=n,n+=r.count}let i=t[0];e.groups=[i];for(let r=1;r<t.length;r++){const o=t[r];i.materialIndex===o.materialIndex?i.count+=o.count:(i=o,e.groups.push(i))}return e},THREE.BufferGeometryUtils.mergeVertices=function(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},o=e.getIndex(),n=e.getAttribute("position"),i=o?o.count:n.count;let s=0;const u=Object.keys(e.attributes),f={},a={},l=[],c=["getX","getY","getZ","getW"],m=["setX","setY","setZ","setW"];for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.attributes[r];f[r]=new THREE.BufferAttribute(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const n=e.morphAttributes[r];n&&(a[r]=new THREE.BufferAttribute(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized))}const E=Math.log10(1/t),g=Math.pow(10,E);for(let t=0;t<i;t++){const n=o?o.getX(t):t;let i="";for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.getAttribute(r),s=o.itemSize;for(let e=0;e<s;e++)i+=~~(o[c[e]](n)*g)+","}if(i in r)l.push(r[i]);else{for(let t=0,r=u.length;t<r;t++){const r=u[t],o=e.getAttribute(r),i=e.morphAttributes[r],l=o.itemSize,E=f[r],g=a[r];for(let e=0;e<l;e++){const t=c[e],r=m[e];if(E[r](s,o[t](n)),i)for(let e=0,o=i.length;e<o;e++)g[e][r](s,i[e][t](n))}}r[i]=s,l.push(s),s++}}const d=e.clone();for(const t in e.attributes){const e=f[t];if(d.setAttribute(t,new THREE.BufferAttribute(e.array.slice(0,s*e.itemSize),e.itemSize,e.normalized)),t in a)for(let e=0;e<a[t].length;e++){const r=a[t][e];d.morphAttributes[t][e]=new THREE.BufferAttribute(r.array.slice(0,s*r.itemSize),r.itemSize,r.normalized)}}return d.setIndex(l),d},THREE.BufferGeometryUtils.toCreasedNormals=function(e,t=Math.PI/3){const r=Math.cos(t),o=100*(1+1e-10),n=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],i=new THREE.Vector3,s=new THREE.Vector3,u=new THREE.Vector3,f=new THREE.Vector3;function a(e){return`${~~(e.x*o)},${~~(e.y*o)},${~~(e.z*o)}`}const l=e.toNonIndexed(),c=l.attributes.position,m={};for(let e=0,t=c.count/3;e<t;e++){const t=3*e,r=n[0].fromBufferAttribute(c,t+0),o=n[1].fromBufferAttribute(c,t+1),u=n[2].fromBufferAttribute(c,t+2);i.subVectors(u,o),s.subVectors(r,o);const f=(new THREE.Vector3).crossVectors(i,s).normalize();for(let e=0;e<3;e++){const t=a(n[e]);t in m||(m[t]=[]),m[t].push(f)}}const E=new Float32Array(3*c.count),g=new THREE.BufferAttribute(E,3,!1);for(let e=0,t=c.count/3;e<t;e++){const t=3*e,o=n[0].fromBufferAttribute(c,t+0),l=n[1].fromBufferAttribute(c,t+1),E=n[2].fromBufferAttribute(c,t+2);i.subVectors(E,l),s.subVectors(o,l),u.crossVectors(i,s).normalize();for(let e=0;e<3;e++){const o=m[a(n[e])];f.set(0,0,0);for(let e=0,t=o.length;e<t;e++){const t=o[e];u.dot(t)>r&&f.add(t)}f.normalize(),g.setXYZ(t+e,f.x,f.y,f.z)}}return l.setAttribute("normal",g),l},THREE.BufferGeometryUtils.toTrianglesDrawMode=function(e,t){if(t===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===THREE.TriangleFanDrawMode||t===THREE.TriangleStripDrawMode){let r=e.getIndex();if(null===r){const t=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<o.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}const o=r.count-2,n=[];if(t===THREE.TriangleFanDrawMode)for(let e=1;e<=o;e++)n.push(r.getX(0)),n.push(r.getX(e)),n.push(r.getX(e+1));else for(let e=0;e<o;e++)e%2==0?(n.push(r.getX(e)),n.push(r.getX(e+1)),n.push(r.getX(e+2))):(n.push(r.getX(e+2)),n.push(r.getX(e+1)),n.push(r.getX(e)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(n),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}}();
//# sourceMappingURL=/sm/f8a5320c8de140059b967d5ae1dac9b7e724e326561f2904003cfd11d8d602ba.map